substitutions:
  device_name: spa-controller

esphome:
  name: ${device_name}
  friendly_name: Spa Controller
  includes:
    - uart_line_sensor.h
    - spa_climate.h

esp32:
  board: featheresp32-s2
  framework:
    type: arduino

logger:
  level: DEBUG
  baud_rate: 0

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

# UART connection to Arduino Nano
uart:
  id: arduino_uart
  tx_pin: GPIO5
  rx_pin: GPIO16
  baud_rate: 115200
  rx_buffer_size: 256

# Global variables for state tracking
globals:
  - id: spa_light_state
    type: bool
    initial_value: 'false'
  - id: spa_pump_state
    type: bool
    initial_value: 'false'
  - id: spa_circ_state
    type: bool
    initial_value: 'false'
  - id: spa_heating_state
    type: bool
    initial_value: 'false'
  - id: spa_standby_state
    type: bool
    initial_value: 'false'
  - id: spa_program
    type: int
    initial_value: '255'
  - id: spa_target_temp
    type: float
    initial_value: '0.0'
  - id: spa_actual_temp
    type: float
    initial_value: '0.0'
  - id: spa_connected
    type: bool
    initial_value: 'false'

# Text sensor to receive and parse Arduino messages
text_sensor:
  - platform: custom
    lambda: |-
      auto sensor = new UartLineReader(id(arduino_uart));
      App.register_component(sensor);
      return {sensor};
    text_sensors:
      - id: arduino_message
        name: "Arduino Raw Message"
        internal: true
        on_value:
          then:
            - lambda: |-
                std::string msg = x;
                ESP_LOGD("spa", "RX: %s", msg.c_str());

                if (msg.find("STATUS:LIGHT:ON") != std::string::npos) {
                  id(spa_light_state) = true;
                  id(light_switch).publish_state(true);
                } else if (msg.find("STATUS:LIGHT:OFF") != std::string::npos) {
                  id(spa_light_state) = false;
                  id(light_switch).publish_state(false);
                } else if (msg.find("STATUS:PUMP:ON") != std::string::npos) {
                  id(spa_pump_state) = true;
                  id(pump_switch).publish_state(true);
                } else if (msg.find("STATUS:PUMP:OFF") != std::string::npos) {
                  id(spa_pump_state) = false;
                  id(pump_switch).publish_state(false);
                } else if (msg.find("STATUS:CIRC:ON") != std::string::npos) {
                  id(spa_circ_state) = true;
                  id(circ_switch).publish_state(true);
                } else if (msg.find("STATUS:CIRC:OFF") != std::string::npos) {
                  id(spa_circ_state) = false;
                  id(circ_switch).publish_state(false);
                } else if (msg.find("STATUS:HEATING:ON") != std::string::npos) {
                  id(spa_heating_state) = true;
                  ((SpaClimate*)id(spa_climate))->set_heating(true);
                } else if (msg.find("STATUS:HEATING:OFF") != std::string::npos) {
                  id(spa_heating_state) = false;
                  ((SpaClimate*)id(spa_climate))->set_heating(false);
                } else if (msg.find("STATUS:STANDBY:ON") != std::string::npos) {
                  id(spa_standby_state) = true;
                  id(standby_sensor).publish_state(true);
                } else if (msg.find("STATUS:STANDBY:OFF") != std::string::npos) {
                  id(spa_standby_state) = false;
                  id(standby_sensor).publish_state(false);
                } else if (msg.find("STATUS:CONNECTED:YES") != std::string::npos) {
                  id(spa_connected) = true;
                  id(connected_sensor).publish_state(true);
                } else if (msg.find("STATUS:CONNECTED:NO") != std::string::npos) {
                  id(spa_connected) = false;
                  id(connected_sensor).publish_state(false);
                } else if (msg.rfind("STATUS:PROG:", 0) == 0 && msg.length() >= 13) {
                  int prog = msg[12] - '0';
                  if (prog >= 0 && prog <= 4) {
                    id(spa_program) = prog;
                    auto call = id(program_select).make_call();
                    call.set_index(prog);
                    call.perform();
                  }
                } else if (msg.rfind("STATUS:TEMP:", 0) == 0) {
                  size_t pos1 = msg.find(':', 12);
                  if (pos1 != std::string::npos) {
                    float target = atof(msg.substr(12, pos1-12).c_str());
                    float actual = atof(msg.substr(pos1+1).c_str());
                    id(spa_target_temp) = target;
                    id(spa_actual_temp) = actual;
                    // Update climate entity
                    auto *climate = (SpaClimate*)id(spa_climate);
                    climate->set_current_temperature(actual);
                    climate->set_target_temperature(target);
                  }
                }

# Switches for controlling spa
switch:
  - platform: template
    id: light_switch
    name: "Spa Light"
    icon: "mdi:lightbulb"
    lambda: return id(spa_light_state);
    turn_on_action:
      - uart.write:
          id: arduino_uart
          data: "CMD:LIGHT:ON\n"
    turn_off_action:
      - uart.write:
          id: arduino_uart
          data: "CMD:LIGHT:OFF\n"

  - platform: template
    id: pump_switch
    name: "Spa Pump"
    icon: "mdi:pump"
    lambda: return id(spa_pump_state);
    turn_on_action:
      - uart.write:
          id: arduino_uart
          data: "CMD:PUMP:ON\n"
    turn_off_action:
      - uart.write:
          id: arduino_uart
          data: "CMD:PUMP:OFF\n"

  - platform: template
    id: circ_switch
    name: "Spa Circulation"
    icon: "mdi:rotate-3d-variant"
    lambda: return id(spa_circ_state);
    turn_on_action:
      - uart.write:
          id: arduino_uart
          data: "CMD:CIRC:ON\n"
    turn_off_action:
      - uart.write:
          id: arduino_uart
          data: "CMD:CIRC:OFF\n"

# Program selector
select:
  - platform: template
    id: program_select
    name: "Spa Program"
    icon: "mdi:format-list-bulleted"
    options:
      - "Away"
      - "Standard"
      - "Energy"
      - "Super Energy"
      - "Weekend"
    initial_option: "Standard"
    optimistic: true
    set_action:
      - lambda: |-
          int prog = 1;
          if (x == "Away") prog = 0;
          else if (x == "Standard") prog = 1;
          else if (x == "Energy") prog = 2;
          else if (x == "Super Energy") prog = 3;
          else if (x == "Weekend") prog = 4;
          char cmd[20];
          sprintf(cmd, "CMD:PROG:%d\n", prog);
          id(arduino_uart).write_str(cmd);

# Climate entity for spa control
climate:
  - platform: custom
    lambda: |-
      auto spa = new SpaClimate(id(arduino_uart));
      App.register_component(spa);
      return {spa};
    climates:
      - id: spa_climate
        name: "Spa"

# Internal sensors for state tracking (used by climate)
sensor:
  - platform: template
    id: target_temp_sensor
    internal: true

  - platform: template
    id: actual_temp_sensor
    internal: true

# Binary sensors for status
binary_sensor:
  - platform: template
    id: heating_sensor
    internal: true

  - platform: template
    id: standby_sensor
    name: "Spa Standby"
    icon: "mdi:power-standby"

  - platform: template
    id: connected_sensor
    name: "Spa Connected"
    icon: "mdi:connection"
    device_class: connectivity

# Request status on boot and periodically
interval:
  - interval: 60s
    then:
      - uart.write:
          id: arduino_uart
          data: "CMD:STATUS\n"

# Button to manually refresh status
button:
  - platform: template
    name: "Refresh Spa Status"
    icon: "mdi:refresh"
    on_press:
      - uart.write:
          id: arduino_uart
          data: "CMD:STATUS\n"
